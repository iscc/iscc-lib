# CLAUDE.md -- iscc-napi

napi-rs bindings exposing the `iscc-lib` Rust core as a native Node.js addon published as
`@iscc/lib` on npm.

## Crate Role

- Hub-and-spoke binding crate: depends on `iscc-lib` (pure Rust core), adds zero business logic
- Compiles to a `.node` native addon via napi-rs (cdylib crate type)
- Published to npm (not crates.io) -- `publish = false` in Cargo.toml
- Wraps all 22 Tier 1 API symbols as `#[napi]` exports

## Module Layout

```
crates/iscc-napi/
  Cargo.toml          # napi + napi-derive deps, cdylib
  build.rs            # napi_build::setup() -- required by napi-rs
  package.json        # @iscc/lib npm package, @napi-rs/cli devDep
  src/
    lib.rs            # All #[napi] wrapper functions (single file)
  __tests__/
    conformance.test.mjs   # 9 gen_*_v0 functions vs data.json vectors
    functions.test.mjs     # 12 non-gen functions (text utils, algo primitives)
  index.js            # Auto-generated by napi-rs (platform loader)
  index.d.ts          # Auto-generated TypeScript declarations
  *.node              # Compiled native binary (gitignored)
```

- `index.js`, `index.d.ts`, and `*.node` are all gitignored build artifacts
- `package.json` entry points: `"main": "index.js"`, `"types": "index.d.ts"`

## Rust-to-JS Type Mapping

| Rust type (napi boundary)      | JS/TS type                                    | Notes                                                 |
| ------------------------------ | --------------------------------------------- | ----------------------------------------------------- |
| `String`                       | `string`                                      | Owned, UTF-8                                          |
| `Option<String>`               | `string \| undefined \| null`                 | Optional params become nullable                       |
| `Option<u32>` / `Option<bool>` | `number \| undefined \| null` / `boolean ...` | napi-derive handles optional scalars                  |
| `Buffer`                       | `Buffer`                                      | Node.js Buffer; use `data.as_ref()` for `&[u8]`       |
| `Vec<String>`                  | `Array<string>`                               | Collected from `&[&str]` via intermediate Vec         |
| `Vec<i32>` / `Vec<u32>`        | `Array<number>`                               | JS numbers map to i32/u32 per signature               |
| `Vec<Vec<i32>>`                | `Array<Array<number>>`                        | Nested arrays (frame signatures)                      |
| `Vec<Buffer>`                  | `Array<Buffer>`                               | Used by `alg_cdc_chunks` return                       |
| `napi::Result<T>`              | throws on Err                                 | Maps `iscc_lib::Error` via `napi::Error::from_reason` |
| `bool`                         | `boolean`                                     | Direct mapping                                        |

## Build Commands

```bash
# Build the native addon (from crate directory)
cd crates/iscc-napi && npm run build          # release: napi build --platform --release
cd crates/iscc-napi && npm run build:debug    # debug:   napi build --platform

# Run tests (requires build first)
cd crates/iscc-napi && npm test               # node --test __tests__/*.test.mjs

# Cargo-level build (does not produce index.js/index.d.ts -- use npm run build instead)
cargo build -p iscc-napi
```

- `npm run build` invokes `@napi-rs/cli` which runs `cargo build`, generates `index.js` (platform
    loader) and `index.d.ts` (TS declarations), and produces the `.node` binary
- Plain `cargo build -p iscc-napi` only produces the `.node` binary without JS/TS artifacts
- Tests use Node.js built-in test runner (`node:test`) with no external test framework dependency

## napi-rs Patterns and Macros

- Every exported function uses `#[napi(js_name = "snake_case")]` to preserve Python/Rust naming
    convention in JS (the codebase uses snake_case across all language bindings)
- `napi_build::setup()` in `build.rs` is mandatory -- it sets linker flags for the native addon
- Rust docstrings on `#[napi]` functions propagate to `index.d.ts` as JSDoc comments
- `Buffer` (from `napi::bindgen_prelude::Buffer`) is the type for byte data, not `Vec<u8>`
- Return `napi::Result<T>` for fallible functions; use `napi::Error::from_reason(e.to_string())` to
    convert `iscc_lib::Error` -- never panic across FFI
- Infallible functions (text utils) return the value directly, no `napi::Result` wrapper
- Default parameter values are applied in the Rust wrapper, not in JS: `bits.unwrap_or(64)`,
    `wide.unwrap_or(false)`
- `Vec<String>` inputs require an intermediate `let refs: Vec<&str>` conversion before passing to
    core functions that accept `&[&str]`

## Test Patterns

- **Conformance tests** (`conformance.test.mjs`): parametrized over vendored `data.json` vectors at
    `crates/iscc-lib/tests/data.json` -- each `gen_*_v0` function must match the `iscc` output field
    for every test case
- **Function tests** (`functions.test.mjs`): unit tests for all 12 non-gen bindings (text utils,
    `encode_base64`, `iscc_decompose`, `conformance_selftest`, `sliding_window`, algorithm
    primitives, `soft_hash_video_v0`)
- Tests import from `../index.js` (the napi-generated platform loader)
- Test files use `.mjs` extension (ESM) with `node:test` and `node:assert`
- No mocking -- tests call real Rust functions through the native addon
- Hex-encoded byte streams in data.json use `stream:<hex>` prefix, decoded via
    `Buffer.from(hex, 'hex')`
- `meta` inputs that are objects are JSON-stringified with sorted keys before passing to Rust

## Publishing Constraints

- npm package name: `@iscc/lib` (scoped under `@iscc` org)
- Platform-specific packages go in `npm/` subdirectory (e.g., `@iscc/lib-darwin-arm64`) --
    auto-generated by `napi artifacts` during CI
- `optionalDependencies` in root `package.json` pull in the correct platform binary at install time
- The auto-generated `index.js` handles platform detection and loads the right `.node` file
- Build matrix targets (from `package.json` napi config):
    - Default triples: `x86_64-apple-darwin`, `x86_64-pc-windows-msvc`, `x86_64-unknown-linux-gnu`
    - Additional: `aarch64-unknown-linux-gnu`
- npm auth uses `NODE_AUTH_TOKEN` secret (not OIDC -- npm does not support trusted publishing)
- Version must stay in sync with workspace version (`0.1.0`) -- coordinated by
    `scripts/sync_versions.py`

## Common Pitfalls

- **Do not run `cargo build` alone** -- use `npm run build` to get the JS/TS artifacts alongside the
    `.node` binary
- **Do not add business logic** -- this crate is a thin translation layer; all computation belongs
    in `iscc-lib`
- **Do not expose Rust enums** directly via napi -- they break when variants are added; use strings
    or integers instead
- **Do not return structured objects** -- current bindings return only the `iscc` string field from
    result structs (e.g., `r.iscc`), not the full result; keep this pattern consistent
- **Do not use `Vec<u8>`** for byte parameters -- use `Buffer` from `napi::bindgen_prelude`
- **Do not forget `napi_build::setup()`** in `build.rs` -- the addon will fail to link without it
- **Do not add npm dependencies** -- the only devDependency is `@napi-rs/cli`; tests use Node.js
    built-in modules only
- **Do not commit `index.js`, `index.d.ts`, or `*.node`** -- these are generated build artifacts
    (gitignored)
- **Watch for `Option` semantics** -- JS `null` and `undefined` both map to Rust `None`; ensure
    default values match Python bindings exactly (e.g., `bits` defaults to 64)
- **Panic = abort in release** -- any panic in Rust crashes the Node.js process; always convert
    errors to `napi::Result` and never use `.unwrap()` on fallible operations
